/*
 * Tencent is pleased to support the open source community by making
 * Hippy available.
 *
 * Copyright (C) 2022 THL A29 Limited, a Tencent company.
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { BinaryReader } from '../serialization/reader/BinaryReader'
import { NativeRenderImpl } from './NativeRenderImpl';
import { NativeRenderDeserializer } from './serialization/NativeRenderDeserializer'
import { BinaryWriter } from '../serialization/writer/BinaryWriter';
import { NativeRenderSerializer } from './serialization/NativeRenderSerializer';
import { NativeRenderProviderManager } from './NativeRenderProviderManager';
import { HREventType } from './utils/HREventUtils';
import { LogUtils } from '../support/utils/LogUtils';
import { HippyLibrary } from '../hippy_library/HippyLibrary';
import { HippyAny, HippyMap, HippyResource, HippyValue } from '../support/common/HippyTypes';
import { HRRenderViewCreator } from './components/HippyRenderRegisterMap';
import { CreateRenderViewParamsForCApi,
  SetRenderViewFrameParamsForCApi,
  UpdateEventListenerParamsForCApi,
  UpdatePropsParamsForCApi} from './NativeRenderBuilderForCApi';
import { componentSnapshot, componentUtils, display, FrameNode } from '@kit.ArkUI';
import { image } from '@kit.ImageKit';
import { HashMap, util } from '@kit.ArkTS';

export class NativeRenderProvider {
  private readonly TAG = "NativeRenderProvider"
  private readonly EVENT_PREFIX = "on"

  private libHippy: HippyLibrary
  private renderImpl: NativeRenderImpl
  private instanceId: number = 0

  constructor(libHippy: HippyLibrary,
      customRenderViewCreatorMap: Map<string, HRRenderViewCreator> | null,
      customMeasureRenderViews: Array<string> | null) {
    this.libHippy = libHippy
    this.renderImpl = new NativeRenderImpl(libHippy, customRenderViewCreatorMap, customMeasureRenderViews)
  }

  setInstanceId(instanceId: number) {
    this.instanceId = instanceId
    this.renderImpl.setInstanceId(instanceId)
    NativeRenderProviderManager.addRenderProvider(instanceId, this)
  }

  getInstanceId(): number {
    return this.instanceId
  }

  getNativeRenderImpl(): NativeRenderImpl {
    return this.renderImpl
  }

  destroy() {
    NativeRenderProviderManager.removeRenderProvider(this.instanceId)
  }

  bytesToArgument(buffer: ArrayBuffer): Array<HippyAny> {
    let binaryReader = new BinaryReader(new Uint8Array(buffer))
    let deserializer = new NativeRenderDeserializer(binaryReader, null)
    deserializer.readHeader()
    let paramsObj = deserializer.readValue() as Array<HippyAny>

    // debug code
    // deserializer.printValue(paramsObj, '', '')

    return (paramsObj instanceof Array) ? paramsObj : new Array<HippyAny>()
  }

  argumentToBytes(params: HippyAny): ArrayBuffer {
    let binaryWriter = new BinaryWriter()
    let serializer = new NativeRenderSerializer(binaryWriter)
    serializer.writeHeader()
    serializer.writeValue(params)
    return binaryWriter.chunked().buffer
  }

  createNode(rootId: number, buffer: ArrayBuffer) {
    try {
      let nodeList = this.bytesToArgument(buffer)
      this.renderImpl.createNode(rootId, nodeList)
    } catch (e) {
      this.renderImpl.handleRenderException(e)
    }
  }

  updateNode(rootId: number, buffer: ArrayBuffer) {
    try {
      let nodeList = this.bytesToArgument(buffer)
      this.renderImpl.updateNode(rootId, nodeList)
    } catch (e) {
      this.renderImpl.handleRenderException(e)
    }
  }

  moveNode(rootId: number, pid: number, buffer: ArrayBuffer) {
    try {
      let nodeList = this.bytesToArgument(buffer)
      this.renderImpl.moveNode(rootId, pid, nodeList)
    } catch (e) {
      this.renderImpl.handleRenderException(e)
    }
  }

  moveNode2(rootId: number, id_array: Array<number>, to_pid: number, from_pid: number, index: number) {
    try {
      this.renderImpl.moveNode2(rootId, id_array, to_pid, from_pid, index)
    } catch (e) {
      this.renderImpl.handleRenderException(e)
    }
  }

  deleteNode(rootId: number, id_array: Array<number>) {
    try {
      this.renderImpl.deleteNode(rootId, id_array)
    } catch (e) {
      this.renderImpl.handleRenderException(e)
    }
  }

  updateLayout(rootId: number, buffer: ArrayBuffer) {
    try {
      let nodeList = this.bytesToArgument(buffer)
      this.renderImpl.updateLayout(rootId, nodeList)
    } catch (e) {
      this.renderImpl.handleRenderException(e)
    }
  }

  endBatch(rootId: number) {
    try {
      this.renderImpl.endBatch(rootId)
    } catch (e) {
      this.renderImpl.handleRenderException(e)
    }
  }

  updateEventListener(rootId: number, buffer: ArrayBuffer) {
    try {
      let eventList = this.bytesToArgument(buffer)
      this.renderImpl.updateEventListener(rootId, eventList)
    } catch (e) {
      this.renderImpl.handleRenderException(e)
    }
  }

  callUIFunction(rootId: number, nodeId: number, callbackId: number, functionName: string, buffer: ArrayBuffer) {
    try {
      let params = this.bytesToArgument(buffer)
      // If callbackId equal to 0 mean this call does not need to callback.
      this.renderImpl.callUIFunction(rootId, nodeId, functionName, params, (callbackId == 0) ? null : (result: HippyAny) => {
        this.doCallBack(1, callbackId, functionName, rootId, nodeId, result)
      })
    } catch (e) {
      this.renderImpl.handleRenderException(e)
    }
  }

  measure(rootId: number, nodeId: number, width: number, widthMode: number, height: number, heightMode: number): bigint {
    return this.renderImpl.measure(this.libHippy, this.instanceId, rootId, nodeId, width, widthMode, height, heightMode)
  }

  customMeasure(rootId: number, nodeId: number, width: number, widthMode: number, height: number, heightMode: number): bigint {
    return this.renderImpl.customMeasure(this.libHippy, this.instanceId, rootId, nodeId, width, widthMode, height, heightMode)
  }

  spanPosition(rootId: number, nodeId: number, x: number, y: number): void {
    this.renderImpl.spanPosition(rootId, nodeId, x, y);
  }

  dispatchEvent(rootId: number, nodeId: number, eventName: string, params: HippyAny, useCapture: boolean, useBubble: boolean, eventType: HREventType) {
    // Because the native(C++) DOM use lowercase names, convert to lowercase here
    let lowerCaseEventName = eventName.toLowerCase()
    // Compatible with events prefixed with on in old version
    if (lowerCaseEventName.startsWith(this.EVENT_PREFIX)) {
        lowerCaseEventName = lowerCaseEventName.substring(this.EVENT_PREFIX.length)
    }

    if (eventType != HREventType.GESTURE && !this.renderImpl.checkRegisteredEvent(rootId, nodeId, lowerCaseEventName)) {
        return;
    }
    LogUtils.d(this.TAG, "dispatchEvent: id " + nodeId + ", eventName " + eventName
               + ", eventType " + eventType + ", params " + params)

    let buffer: ArrayBuffer | null = null
    if (params != null) {
      try {
        buffer = this.argumentToBytes(params)
      } catch (e) {
        this.renderImpl.handleRenderException(e)
      }
    }
    this.libHippy?.NativeRenderProvider_OnReceivedEvent(this.instanceId, rootId, nodeId, lowerCaseEventName, buffer, useCapture, useBubble)
  }

  doCallBack(result: number, callbackId: number, functionName: string, rootId: number, nodeId: number, params: HippyAny) {
    let buffer: ArrayBuffer | null = null
    if (params != null) {
      try {
        buffer = this.argumentToBytes(params)
      } catch (e) {
        this.renderImpl.handleRenderException(e)
      }
    }
    this.libHippy?.NativeRenderProvider_DoCallBack(this.instanceId, result, functionName, rootId, nodeId, callbackId, buffer)
  }

  // for devtools
  async getComponentSnapshot(componentId: string, resultMap: HippyMap): Promise<HippyMap | null> {
    LogUtils.d(this.TAG, "wangz::componentId::" + JSON.stringify(componentId));
    try {
      let pixmap: PixelMap = await componentSnapshot.get("HippyId" + componentId);
      const imagePackageApi: image.ImagePacker = image.createImagePacker()
      let packOpts: image.PackingOption = {
        format: 'image/png',
        quality: 30,
      }
      const readBuffer = await imagePackageApi.packing(pixmap, packOpts);
      let base64Helper = new util.Base64Helper();
      let uint8Arr = new Uint8Array(readBuffer);
      let pixelStr = base64Helper.encodeToStringSync(uint8Arr);
      LogUtils.d(this.TAG, "wangz::pixelStr::" + pixelStr);
      let rsMap = new Map<string, HippyValue>();
      rsMap.set("screenShot", pixelStr);
      rsMap.set("width", 50);
      rsMap.set("height", 50);
      rsMap.set("screenScale", 1.0);
      LogUtils.d(this.TAG, "wangz::" + JSON.stringify(rsMap));
      return rsMap;
    } catch (e) {
      LogUtils.d(this.TAG, "wangz::error::" + JSON.stringify(e));
    }
    LogUtils.d(this.TAG, "wangz::return::" + JSON.stringify(componentId));
    return null;
  }

  getLocationOnScreen(componentId: string): HippyMap {
    let info = componentUtils.getRectangleById("HippyId" + componentId);
    LogUtils.d(this.TAG, "wangz::info::" + JSON.stringify(info));
    let rsMap = new Map<string, HippyAny>();
    rsMap.set("xOnScreen", info.screenOffset.x as HippyValue);
    rsMap.set("yOnScreen", info.screenOffset.y as HippyValue);
    rsMap.set("viewWidth", info.size.width as HippyValue);
    rsMap.set("viewHeight", info.size.height as HippyValue);
    LogUtils.d(this.TAG, "wangz::return::");
    return rsMap as HippyMap;
  }

  // for c-api
  createRenderViewForCApi(params: CreateRenderViewParamsForCApi): FrameNode | null {
    return this.renderImpl.createRenderViewForCApi(params)
  }

  // for c-api
  updatePropsForCApi(params: UpdatePropsParamsForCApi): void {
    let binaryReader = new BinaryReader(new Uint8Array(params.props as ArrayBuffer))
    let deserializer = new NativeRenderDeserializer(binaryReader, null)
    deserializer.readHeader()
    let propsObj = deserializer.readValue() as HippyMap
    params.props = (propsObj instanceof Map) ? propsObj : new Map()
    this.renderImpl.updatePropsForCApi(params)
  }

  // for c-api
  updateEventListenerForCApi(params: UpdateEventListenerParamsForCApi): void {
    let binaryReader = new BinaryReader(new Uint8Array(params.props as ArrayBuffer))
    let deserializer = new NativeRenderDeserializer(binaryReader, null)
    deserializer.readHeader()
    let propsObj = deserializer.readValue() as HippyMap
    params.props = (propsObj instanceof Map) ? propsObj : new Map()
    this.renderImpl.updateEventListenerForCApi(params)
  }

  // for c-api
  setRenderViewFrameForCApi(params: SetRenderViewFrameParamsForCApi): void {
    this.renderImpl.setRenderViewFrameForCApi(params)
  }

}
